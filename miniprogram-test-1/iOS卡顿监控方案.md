#### 1. 什么是卡顿

> 卡顿就是在应用使用过程中出现界面不响应或者界面渲染粘滞的情况，而应用界面的渲染以及事件响应是在主线程中完成的，出现卡顿的原因可以归结为主线程阻塞。在开发过程中，遇到的造成主线程阻塞的原因可能是：

+ 主线程在进行大量I/O操作：在主线程中写入大量数据
+ 主线程在进行大量计算：代码编写不合理，主线程进行复杂计算；
+ 大量UI绘制：界面过于复杂，UI绘制需要大量时间；
+ 主线程在等锁：主线程需要获得锁A,但是当前某个子线程持有这个锁A,导致主线程不得不等待子线程完成任务。

针对这些问题，如果我们能够获得到卡顿当时应用的主线程堆栈，那么问题就迎刃而解了，有了堆栈，就可以知道主线程在什么函数哪一行代码卡住了，是在等什么锁，还是进行I/O操作，或者是进行复杂计算，有了堆栈，就可以对问题进行针对性解决。


##### 原理

在iOS/macOS平台应用中，主线程有一个Runloop。Runloop 是一个 Event Loop 模型，让线程可以处于接收消息、处理事件、进入等待而不马上退出。在进入事件的前后，Runloop 会向注册的 Observer 通知相应的事件。

![](https://raw.githubusercontent.com/wiki/Tencent/matrix/images/blockmonitor/simple-runloop-model.png)


卡顿监控在Runloop的起始位置和结束位置添加Observer,从而获得主线程的开始和结束状态，卡顿监控实现是开启一个主线程定时检查主线程的状态，当主线程的状态运行超过一定的阈值则认为主线程卡顿，从而标记为一个卡顿。


![](https://raw.githubusercontent.com/wiki/Tencent/matrix/images/blockmonitor/main-thread-lag-check.png)

目前微信使用的卡顿监控，主线程Runloop超时时间的阈值是2秒，子线程的检查周期是1秒，每隔1秒，子线程检查主线程的运行状态，如果检查到主线程的Runloop运行超过2秒则认为是卡顿，并获取当前的线程快照。

同时，我们也认为CPU过高也可能导致应用出现卡顿，所以在子线程检查主线程状态的同时，如果检测到CPU占用过高，会捕获当前的线程快照保存到文件中，目前微信应用中认为，单核CPU的占用超过了80%。此时CPU占用就过高了；

#### 退火算法

为了降低检测带来的性能损耗，我们为检测线程增加了退火算法：


+ 每次子线程检查到主线程卡顿，会先获得主线程的堆栈并保存到内存中（不会直接去获得线程快照保存到文件中）；
+ 将获得的主线程堆栈与上次卡顿获得的主线程堆栈进行比对：
	+ 如果堆栈不同，则获得当前的线程快照并写入文件中；
	+ 如果相同则会跳过，并按照斐波那契数列将检查时间递增知道没有遇到卡顿或者主线程卡顿堆栈不一样；


#### 耗时堆栈提取

---

子线程检测到主线程Runloop时，会获得当前的线程快照当做卡顿文件，但是这个当前的主线程堆栈不一定是最耗时的堆栈，不一定是导致主线程超时的主要问题：


例如：主线程在绘制一个微信logo，过程如下：

![](https://raw.githubusercontent.com/wiki/Tencent/matrix/images/blockmonitor/draw-wechat-logo.png)


子线程在检测到超出阀值时获得的线程快照，主线程的当前任务是”画小气泡“，但其实”画大气泡“才是耗时操作，导致主线程超时的主要原因。Matrix卡顿监控通过主线程耗时堆栈提取来解决这个问题。

卡顿监控定时获取主线程堆栈，并将堆栈保存到内存的一个循环队列中，如下图，每间隔时间t获得一个堆栈，然后将堆栈保存到一个最大个数为3的循环队列中，有一个游标不断的指向最近的堆栈。



